// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel GameOfLife

struct Cell
{
    float2 position;
    int state;
    int nextState;

    int idx;
    int idy;
    int idz;
};


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<Cell> cells;

uint sizeX;
uint sizeY;

int deadState = 0;
int aliveState = 1;

float4 deadColor = {0.0f, 0.0f, 0.0f, 255.0f};
float4 aliveColor = { 255.0f, 1.0f, 1.0f, 255.0f };

[numthreads(16, 16, 1)]
void GameOfLife (uint3 id : SV_DispatchThreadID)
{
    //Get our cells index
    uint myCellIdx = id.x + (id.x * id.y);

    //Exit early if we are a cell that doesnt matter
    if (myCellIdx >= sizeX * sizeY)
        return;

    Cell myCell = cells[myCellIdx];

    //Same for the edges of the cube. In reality we should really check the game that is our neighbor but that sounds hard so I simply wont
    if (myCellIdx < sizeX || myCellIdx >= sizeX * (sizeY - 1)) //same as y == 0 || y == sizeY - 1
    {
        myCell.nextState = deadState;
        cells[myCellIdx] = myCell;
        return;
    }

    if(myCellIdx % sizeX == 0 || (myCellIdx + 1) % sizeX == 0 ) //Same as x == 0 || x == sizeX - 1
    {
        myCell.nextState = deadState;
        cells[myCellIdx] = myCell;
        return;
    }

    int numAliveNeighbors = 0;

    //Get the state of all 8 neighbors
    //Go up is + sizeX
    //Go down is - sizeX
    //Left or right is just + - 1
    numAliveNeighbors += cells[myCellIdx + sizeX].state;        //N
    numAliveNeighbors += cells[myCellIdx + sizeX + 1].state;    //NE
    numAliveNeighbors += cells[myCellIdx + 1].state;            //E
    numAliveNeighbors += cells[myCellIdx - sizeX + 1].state;    //SE
    numAliveNeighbors += cells[myCellIdx - sizeX].state;        //S
    numAliveNeighbors += cells[myCellIdx - sizeX - 1].state;    //SW
    numAliveNeighbors += cells[myCellIdx - 1].state;            //W
    numAliveNeighbors += cells[myCellIdx + sizeX - 1].state;    //NW

    if (myCell.state == aliveState)
    {
        if (numAliveNeighbors == 2 || numAliveNeighbors == 3)
        {
            myCell.nextState = aliveState;
        }
        else
        {
            myCell.nextState = deadState;
        }
    }
    else
    {
        if (numAliveNeighbors == 3)
        {
            myCell.nextState = aliveState;
        }
        else
        {
            myCell.nextState = deadState;
        }
    }

    myCell.idx = id.x;
    myCell.idy = id.y;
    myCell.idz = id.z;

    cells[myCellIdx] = myCell;
    
    //We could do something here where we wait for every other cell to finish their work then we advance the next state to current state
    //Not sure how to do that in all honestly
    //We can sync with our local group easily, but this does NOT ensure that the entire game is finished
    //I will try that in the next commit and see how that goes

    //We could also do something here where we are passed a render texture and we can immediatly write to it in the shader.
    //However I again do not know how to apply those values to a Texture2D which is attached to the material
    //I believe there is a way to do it, im just not sure how
}
